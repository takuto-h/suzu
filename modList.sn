
module List:
  class C:
    def Nil()
    def Cons(x, xs)
  end

  let Nil = Nil()
  
  def fold_left(init, lst, proc):
    match(lst):
    case([]):
      init
    case([x | xs]):
      fold_left(proc(init, x), xs, proc)
    end
  end

  def fold_right(lst, init, proc):
    match(lst):
    case([]):
      init
    case([x | xs]):
      proc(x, fold_right(xs, init, proc))
    end
  end

  def append(lst1, lst2):
    fold_right(lst1, lst2)^(elem, acc):
      [elem | acc]
    end
  end

  module Open:
    def C#(==)(self, other):
      match((self, other)):
      case(([] , [])):
        true
      case(([x | xs], [y | ys]))when(x == y && xs == ys):
        true
      case(_):
        false
      end
    end

    let C#(++) = append

    def C#fold_left(self, init, proc):
      fold_left(init, self, proc)
    end

    let C#fold_right = fold_right

    export C#(==), C#(++), C#fold_left, C#fold_right
  end

  export C, Nil, Cons, fold_left, fold_right, append, Open
end

open List::Open
