
module Pervasives:
  exception Invalid_argument(str)
  exception Exit()

  let reset = Builtin::reset
  let shift = Builtin::shift

  def begin(thunk):
    thunk()
  end

  def if(cond, then_thunk, :else else_thunk=^{}):
    match(cond):
    case(true):
      then_thunk()
    case(false):
      else_thunk()
    end
  end

  def while(test_thunk, :do body_thunk):
    if(test_thunk()):
      body_thunk()
      while(test_thunk, :do body_thunk)
    end
  end

  def write_line(*args):
    Builtin::write_line(String::format(*args))
  end
  
  let read_line = Builtin::read_line

  def p(value):
    Builtin::write_line(Builtin::show(value))
  end

  export Invalid_argument, Exit, reset, shift, begin, if, while, write_line, read_line, p
end

open Pervasives

trait DefaultToString(C):
  let C#to_string = Builtin::show
  export C#to_string
end

trait DefaultCompare(C):
  let C#(>) = Builtin::gt
  let C#(<) = Builtin::lt
  let C#(>=) = Builtin::ge
  let C#(<=) = Builtin::le
  let C#(==) = Builtin::eq
  let C#(!=) = Builtin::ne
  let C#(<=>) = Builtin::compare
  export C#(>), C#(<), C#(>=), C#(<=), C#(==), C#(!=), C#(<=>)
end

trait Compare(C, C#(<=>)):
  def C#(>)(self, other){ (self <=> other) > 0 }end
  def C#(<)(self, other){ (self <=> other) < 0 }end
  def C#(>=)(self, other){ (self <=> other) >= 0 }end
  def C#(<=)(self, other){ (self <=> other) <= 0 }end
  def C#(==)(self, other){ (self <=> other) == 0 }end
  def C#(!=)(self, other){ (self <=> other) != 0 }end
  export C#(>), C#(<), C#(>=), C#(<=), C#(==), C#(!=), C#(<=>)
end

module Unit:
  class C

  module Open:
    include DefaultCompare(C)
    include DefaultToString(C)
  end

  export C, Open
end

open Unit::Open

module Bool:
  class C

  module Open:
    include DefaultCompare(C)
    include DefaultToString(C)

    let C#(!) = Builtin::bool_not

    export C#(!)
  end

  export C, Open
end

open Bool::Open

module Int:
  class C

  module Open:
    include DefaultCompare(C)
    include DefaultToString(C)
  
    let C#(+) = Builtin::int_add
    let C#(-) = Builtin::int_sub
    let C#(*) = Builtin::int_mul
    let C#(/) = Builtin::int_div
    let C#(%) = Builtin::int_mod
    let C#(~+) = Builtin::int_plus
    let C#(~-) = Builtin::int_minus

    export C#(+), C#(-), C#(*), C#(/), C#(%), C#(~+), C#(~-)
  end
  
  export C, Open
end

open Int::Open

module Char:
  class C

  let code = Builtin::char_code

  def digit?(c):
    String::contain?("0123456789", c)
  end

  def digit_to_int(c):
    code(c) - code('0')
  end

  module Open:
    include DefaultCompare(C)

    let C#to_string = Builtin::char_to_string
    
    export C#to_string
  end
  
  export C, code, digit?, digit_to_int, Open
end

open Char::Open

module String:
  class C

  let get = Builtin::string_get
  let length = Builtin::string_length
  let contain? = Builtin::string_contain?
  
  module Format:
    exception Illegal_format()
    
    class insn:
      def String(str)
      def Placeholder(n)
    end
    
    let initial_unformatted_buffer_size = 16
    let initial_formatted_buffer_size = 256

    def parse_format_insns(strm, rev_insns):
      match(Stream::peek(strm)):
      case(Some('{')):
        Stream::junk(strm)
        if(Stream::peek(strm) == Some('{')):
          parse_string(strm, '{', rev_insns)
        else:
          parse_placeholder(strm, rev_insns)
        end
      case(Some('}')):
        Stream::junk(strm)
        if(Stream::peek(strm) == Some('}')):
          parse_string(strm, '}', rev_insns)
        else:
          throw Illegal_format()
        end
      case(Some(c)):
        parse_string(strm, c, rev_insns)
      case(None()):
        List::rev(rev_insns)
      end
    end

    def parse_placeholder(strm, rev_insns):
      def loop(n):
        match(Stream::peek(strm)):
        case(Some(c))when(Char::digit?(c)):
          let i = Char::digit_to_int(c)
          Stream::junk(strm)
          loop(n * 10 + i)
        case(Some('}')):
          Stream::junk(strm)
          parse_format_insns(strm, [Placeholder(n) | rev_insns])
        case(Some(_) or None()):
          throw Illegal_format()
        end
      end
      loop(0)
    end

    def parse_string(strm, c, rev_insns):
      let buf = Buffer::create(initial_unformatted_buffer_size)
      Buffer::add_char(buf, c)
      Stream::junk(strm)
      def loop():
        match(Stream::peek(strm)):
        case(Some('{')):
          Stream::junk(strm)
          if(Stream::peek(strm) == Some('{')):
            Buffer::add_char(buf, '{')
            Stream::junk(strm)
            loop()
          else:
            parse_placeholder(strm, [String(Buffer::contents(buf)) | rev_insns])
          end
        case(Some('}')):
          Stream::junk(strm)
          if(Stream::peek(strm) == Some('}')):
            Buffer::add_char(buf, '}')
            Stream::junk(strm)
            loop()
          else:
            throw Illegal_format()
          end
        case(Some(c)):
          Buffer::add_char(buf, c)
          Stream::junk(strm)
          loop()
        case(None):
          List::rev([String(Buffer::contents(buf)) | rev_insns])
        end
      end
      loop()
    end

    def execute_format_insns(insns, args, buf):
      match(insns):
      case([]):
        Buffer::contents(buf)
      case([String(str) | insns]):
        Buffer::add_string(buf, str)
        execute_format_insns(insns, args, buf)
      case([Placeholder(n) | insns]):
        match(Args::get(args, n)):
        case(Some(arg)):
          Buffer::add_string(buf, arg.to_string)
        case(None()):
          throw Illegal_format
        end
        execute_format_insns(insns, args, buf)
      end
    end

    def f(str, *args):
      let insns = parse_format_insns(Stream::from_string(str), [])
      let buf = Buffer::create(initial_formatted_buffer_size)
      execute_format_insns(insns, args, buf)
    end

    export f
  end

  let format = Format::f

  module Open:
    include DefaultCompare(C)

    def C#([])(self, index):
      match(get(self, index)):
      case(Some(c)):
        c
      case(None()):
        throw Invalid_argument("index out of bounds")
      end
    end
    
    def C#to_string(self):
      self
    end
    
    export C#([]), C#to_string
  end
  
  export C, get, length, contain?, format, Open
end

open String::Open

module Args:
  class C

  let get = Builtin::args_get

  module Open:
    include DefaultCompare(C)
    include DefaultToString(C)
  end
  
  export C, get, Open
end

open Args::Open

module Class:
  class C

  let of = Builtin::class_of

  module Open:
    include DefaultCompare(C)
    include DefaultToString(C)
  end
  
  export C, of, Open
end

open Class::Open

module Module:
  class C

  module Open:
    include DefaultToString(C)
  end

  export C, Open
end

open Module::Open

module Proc:
  class C

  module Open:
    include DefaultToString(C)
  end

  export C, Open
end

open Proc::Open

module List:
  class C:
    def Nil()
    def Cons(x, xs)
  end

  let Nil = Nil()
  
  def fold_left(init, lst, proc):
    match(lst):
    case([]):
      init
    case([x | xs]):
      fold_left(proc(init, x), xs, proc)
    end
  end

  def fold_right(lst, init, proc):
    match(lst):
    case([]):
      init
    case([x | xs]):
      proc(x, fold_right(xs, init, proc))
    end
  end

  def append(lst1, lst2):
    fold_right(lst1, lst2)^(elem, acc):
      [elem | acc]
    end
  end

  def rev(lst):
    fold_left([], lst)^(acc, elem):
      [elem | acc]
    end
  end

  def find(lst, pred):
    match(lst):
    case([]):
      None()
    case([x | _])when(pred(x)):
      Some(x)
    case([_ | xs]):
      find(xs, pred)
    end
  end

  def flatten(lst):
    fold_right(lst, [])^(elem, acc):
      append(elem, acc)
    end
  end

  def map(lst, proc):
    fold_right(lst, [])^(elem, acc):
      [proc(elem) | acc]
    end
  end

  module Open:
    include Compare(C)^(self, other):
      match(self, other):
      case([] , []):
        0
      case([] , [y | ys]):
        -1
      case([x | xs] , []):
        1
      case([x | xs], [y | ys])when((x <=> y) != 0):
        x <=> y
      case([x | xs], [y | ys]):
        xs <=> ys
      end
    end

    let C#(++) = append

    export C#(++)
  end

  export C, Nil, Cons, fold_left, fold_right, append, rev, find, flatten, map, Open
end

open List::Open

module Ref:
  class C = make:
    mutable value
  end

  module Open:
    include Compare(C)^(self, other):
      self.value <=> other.value
    end

    let C#value = C#value
    let C#(value=) = C#(value=)

    export C#value, C#(value=)
  end

  export make, C, Open
end

open Ref::Open

module Exn:
  class C

  module Open:
    include DefaultToString(C)
  end

  export C, Open
end

open Exn::Open

module Option:
  class C:
    def None()
    def Some(x)
  end

  def bind(m, proc):
    match(m):
    case(None()):
      None()
    case(Some(x)):
      proc(x)
    end
  end

  module Open:
    include DefaultCompare(C)

    let None = None
    let Some = Some

    def C#to_string(self):
      match(self):
      case(None()):
        "None()"
      case(Some(x)):
        String::format("Some({0})", x)
      end
    end

    export None, Some, C#to_string
  end

  export C, None, Some, bind, Open
end

open Option::Open

module Stream:
  class C = make:
    str
    len
    mutable idx
  end

  def from_string(str):
    make(str, String::length(str), 0)
  end

  def peek(stream):
    if(stream.idx >= stream.len):
      None()
    else:
      Some(stream.str[stream.idx])
    end
  end

  def junk(stream):
    stream.idx = stream.idx + 1
  end

  export C, from_string, peek, junk
end

module Buffer:
  class C

  let create = Builtin::buffer_create
  let add_string = Builtin::buffer_add_string
  let contents = Builtin::buffer_contents

  def add_char(buf, c):
    add_string(buf, Builtin::char_to_string(c))
  end

  export C, create, add_string, add_char, contents
end
