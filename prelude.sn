
module Pervasives:
  exception Exit()

  def if(cond, then_thunk, :else else_thunk=^{}):
    match(cond):
    case(true):
      then_thunk()
    case(false):
      else_thunk()
    end
  end

  def while(test_thunk, :do body_thunk):
    if(test_thunk()):
      body_thunk()
      while(test_thunk, :do body_thunk)
    end
  end

  let write_line = Builtin::write_line
  let read_line = Builtin::read_line

  def p(value):
    write_line(Builtin::show(value))
  end

  export Exit, if, while, write_line, read_line, p
end

open Pervasives

trait DefaultToString(C):
  let C#to_string = Builtin::show
  export C#to_string
end

trait DefaultCompare(C):
  let C#(>) = Builtin::gt
  let C#(<) = Builtin::lt
  let C#(>=) = Builtin::ge
  let C#(<=) = Builtin::le
  let C#(==) = Builtin::eq
  let C#(!=) = Builtin::ne
  let C#(<=>) = Builtin::compare
  export C#(>), C#(<), C#(>=), C#(<=), C#(==), C#(!=), C#(<=>)
end

trait Compare(C, C#(<=>)):
  def C#(>)(self, other){ (self <=> other) > 0 }end
  def C#(<)(self, other){ (self <=> other) < 0 }end
  def C#(>=)(self, other){ (self <=> other) >= 0 }end
  def C#(<=)(self, other){ (self <=> other) <= 0 }end
  def C#(==)(self, other){ (self <=> other) == 0 }end
  def C#(!=)(self, other){ (self <=> other) != 0 }end
  export C#(>), C#(<), C#(>=), C#(<=), C#(==), C#(!=), C#(<=>)
end

module Unit:
  class C

  module Open:
    include DefaultCompare(C)
    include DefaultToString(C)
  end

  export C, Open
end

open Unit::Open

module Bool:
  class C

  module Open:
    include DefaultCompare(C)
    include DefaultToString(C)

    let C#(!) = Builtin::not

    export C#(!)
  end

  export C, Open
end

open Bool::Open

module Int:
  class C

  module Open:
    include DefaultCompare(C)
    include DefaultToString(C)
  
    let C#(+) = Builtin::add
    let C#(-) = Builtin::sub
    let C#(*) = Builtin::mul
    let C#(/) = Builtin::div
    let C#(%) = Builtin::mod
    let C#(~+) = Builtin::plus
    let C#(~-) = Builtin::minus

    export C#(+), C#(-), C#(*), C#(/), C#(%), C#(~+), C#(~-)
  end
  
  export C, Open
end

open Int::Open

module Char:
  class C

  module Open:
    include DefaultCompare(C)

    let C#to_string = Builtin::char_to_string
    
    export C#to_string
  end
  
  export C, Open
end

open Char::Open

module String:
  class C

  let length = Builtin::string_length
  
  //let format = Builtin::format

  module Open:
    include DefaultCompare(C)

    let C#([]) = Builtin::string_get
    
    def C#to_string(self):
      self
    end
    
    export C#([]), C#to_string
  end
  
  //export C, format, Open
  export C, length, Open
end

open String::Open

module Args:
  class C

  module Open:
    include DefaultCompare(C)
    include DefaultToString(C)
  end
  
  export C, Open
end

open Args::Open

module Class:
  class C

  let of = Builtin::class_of

  module Open:
    include DefaultCompare(C)
    include DefaultToString(C)
  end
  
  export C, of, Open
end

open Class::Open

module Module:
  class C

  module Open:
    include DefaultToString(C)
  end

  export C, Open
end

open Module::Open

module Proc:
  class C

  module Open:
    include DefaultToString(C)
  end

  export C, Open
end

open Proc::Open

module List:
  class C:
    def Nil()
    def Cons(x, xs)
  end

  let Nil = Nil()
  
  def fold_left(init, lst, proc):
    match(lst):
    case([]):
      init
    case([x | xs]):
      fold_left(proc(init, x), xs, proc)
    end
  end

  def fold_right(lst, init, proc):
    match(lst):
    case([]):
      init
    case([x | xs]):
      proc(x, fold_right(xs, init, proc))
    end
  end

  def append(lst1, lst2):
    fold_right(lst1, lst2)^(elem, acc):
      [elem | acc]
    end
  end

  module Open:
    include Compare(C)^(self, other):
      match(self, other):
      case([] , []):
        0
      case([] , [y | ys]):
        -1
      case([x | xs] , []):
        1
      case([x | xs], [y | ys])when((x <=> y) != 0):
        x <=> y
      case([x | xs], [y | ys]):
        xs <=> ys
      end
    end

    let C#(++) = append

    def C#fold_left(self, init, proc):
      fold_left(init, self, proc)
    end

    let C#fold_right = fold_right

    export C#(++), C#fold_left, C#fold_right
  end

  export C, Nil, Cons, fold_left, fold_right, append, Open
end

open List::Open

module Ref:
  class C = make:
    mutable value
  end

  module Open:
    include Compare(C)^(self, other):
      self.value <=> other.value
    end

    let C#value = C#value
    let C#(value=) = C#(value=)

    export C#value, C#(value=)
  end

  export make, C, Open
end

open Ref::Open

module Exn:
  class C

  module Open:
    include DefaultToString(C)
  end

  export C, Open
end

open Exn::Open

module Option:
  class C:
    def None()
    def Some(x)
  end

  module Open:
    include DefaultCompare(C)
    include DefaultToString(C)

    let None = None
    let Some = Some

    export None, Some
  end

  export C, Open
end

open Option::Open

module Stream:
  class C = make:
    str
    len
    mutable idx
  end

  def from_string(str):
    make(str, String::length(str), 0)
  end

  def peek(stream):
    if(stream.idx >= stream.len):
      None()
    else:
      Some(stream.str[stream.idx])
    end
  end

  def junk(stream):
    stream.idx = stream.idx + 1
  end

  export C, from_string, peek, junk
end

module Buffer:
  class C

  let create = Builtin::buffer_create
  let add_string = Builtin::buffer_add_string
  let contents = Builtin::buffer_contents

  export C, create, add_string, contents
end
