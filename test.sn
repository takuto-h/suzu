
write_line("hello, world.")


def fac(n):
  if(n == 0):
    1
  else:
    n * fac(n - 1)
  end
end

write_line("fac(10) = {0}", fac(10))


class UgradStudent = make_ugrad_student:
  name
  college
  mutable grade
end

let me = make_ugrad_student("Takuto Hayashi", "College of Information Science", 3)
write_line("{0}", me.name) //=> Takuto Hayashi
write_line("{0}", me.college) //=> College of Information Science
write_line("{0}", me.grade) //=> 3

def UgradStudent#promote!(self):
  if(self.grade < 4):
    self.grade = self.grade + 1
  end
  self.grade
end

me.promote!
write_line("{0}", me.grade) //=> 4

trait Student(C, C#name, C#department):
  def C#introduce_oneself(self):
    write_line("My name is {0}. I'm a member of {1}.", self.name, self.department)
  end

  export C#introduce_oneself
end

class GradStudent = make_grad_student:
  name
  school
  mutable grade
end

let taro = make_grad_student("Taro Tsukuba", "Graduate School of Systems and Information Engineering", 1)

open Student(UgradStudent, UgradStudent#name, UgradStudent#college)
open Student(GradStudent, GradStudent#name, GradStudent#school)

me.introduce_oneself //=> My name is Takuto Hayashi. I'm a member of College of Information Science.
taro.introduce_oneself //=> My name is Taro Tsukuba. I'm a member of Graduate School of Systems and Information Engineering.


let lst1 = [1, 2, 3]
let lst2 = [4, 5, 6]

def List::C#to_string(self):
  match(self):
  case([]):
    "[]"
  case([x | xs]):
    let str = String::format("{0}", x)
    let str = xs.fold_left(str)^(acc, elem):
      String::format("{0}, {1}", acc, elem)
    end
    String::format("[{0}]", str)
  end
end

write_line("{0}", lst1) //=> [1, 2, 3]
write_line("{0}", lst2) //=> [4, 5, 6]
write_line("{0}", lst1 ++ lst2) //=> [1, 2, 3, 4, 5, 6]


trait Account(C, C#balance, C#(balance=)):
  def C#deposit!(self, x):
    self.balance = self.balance + x
  end

  def C#withdraw!(self, x):
    self.balance = self.balance - x
    if(self.balance < 0):
      self.balance = 0
    end
  end

  export C#deposit!, C#withdraw!
end

class BankAccount = make_bank_account:
  mutable balance
end

open Account(BankAccount, BankAccount#balance, BankAccount#(balance=))

def create_bank_account():
  make_bank_account(0)
end

let account = create_bank_account()

account.balance = 200
write_line("{0}(200)", account.balance)
account.deposit!(50)
write_line("{0}(250)", account.balance)
account.withdraw!(100)
write_line("{0}(150)", account.balance)
account.withdraw!(200)
write_line("{0}(0)", account.balance)

class StockAccount = make_stock_account:
  mutable num_shares
  mutable price_per_share
end

def StockAccount#balance(self):
  self.num_shares * self.price_per_share
end

def StockAccount#(balance=)(self, x):
  self.num_shares = x / self.price_per_share
end

open Account(StockAccount, StockAccount#balance, StockAccount#(balance=))

def create_stock_account():
  make_stock_account(10, 30)
end

let stock = create_stock_account()

write_line("{0}(10)", stock.num_shares)
write_line("{0}(30)", stock.price_per_share)
write_line("{0}(300)", stock.balance)
stock.balance = 150
write_line("{0}(5)", stock.num_shares)

stock.balance = 600
write_line("{0}(600)", stock.balance)
write_line("{0}(20)", stock.num_shares)
stock.deposit!(60)
write_line("{0}(660)", stock.balance)
write_line("{0}(22)", stock.num_shares)

class Point = make_point:
  x
  y
end

let p1 = make_point(1, 2)
let p2 = make_point(1, 2)
let p3 = make_point(2, 2)

module Temp:
  def Point#(==)(self, other):
    self.x == other.x && self.y == other.y
  end

  write_line("{0}", p1 == p2) //=> true
  write_line("{0}", p2 == p3) //=> false
end

//write_line("{0}", p1 == p2) //=> <error>


let x = (1, 2, 3, :p 4)

let (a, b, c, :p d, :q e=5) = x

write_line("{0}{1}{2}{3}{4}", a, b, c, d, e)


def my_if1(cond, then_thunk, :else else_thunk=^{}):
  if(cond):
    then_thunk()
  else:
    else_thunk()
  end
end

my_if1(true):
  write_line("ok!")
else:
  write_line("NG")
end

my_if1(true):
  write_line("ok!")
end

def my_if2(cond, :then then_thunk=^{}, :else else_thunk=^{}):
  if(cond):
    then_thunk()
  else:
    else_thunk()
  end
end

my_if2(false):
then:
  write_line("NG")
else:
  write_line("ok!")
end

my_if2(false):
else:
  write_line("ok!")
end

my_if2(false):
then:
  write_line("NG")
end

my_if2(false):
end

def my_while(test_thunk, :do body_thunk):
  while: test_thunk()
  do:
    body_thunk()
  end
end

def Ref::C#zero?(self):
  self.value == 0
end

def Ref::C#decr!(self):
  self.value = self.value - 1
  self.value
end

let counter = Ref::make(5)
my_while: !counter.zero?
do:
  write_line("{0}", counter.decr!)
end


trait Reify(bind):
  def reify(proc):
    reset:
      proc()
    end
  end

  def reflect(m):
    shift^(k):
      bind(m, k)
    end
  end

  export reify, reflect
end

begin:
  open Reify(Option::bind)
  let result = reify:
    let a = reflect(List::find([1, 0, 3], ^(n){ n == 2 }))
    let b = reflect(List::find([2, 3, 1], ^(n){ n == 3 }))
    Some([a, b])
  end
  write_line("{0}", result)
  let result = reify:
    let a = reflect(List::find([1, 0, 3, 2], ^(n){ n == 2 }))
    let b = reflect(List::find([2, 3, 1], ^(n){ n == 3 }))
    Some([a, b])
  end
  write_line("{0}", result)
end

begin:
  open Reify^(m, proc):
    List::flatten(List::map(m, proc))
  end
  let result = reify:
    let a = reflect([1, 2, 3])
    let b = reflect([4, 5, 6])
    let c = a * b
    if(c % 6 != 0):
      []
    else:
      [c]
    end
  end
  write_line("{0}", result)
end
