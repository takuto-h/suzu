
write_line("hello, world.")


def fac(n):
  if(n == 0):
    1
  else:
    n * fac(n - 1)
  end
end

write_line("fac(10) = {0}", fac(10))


class UgradStudent = make_ugrad_student:
  name
  college
  mutable grade
end

let me = make_ugrad_student("Takuto Hayashi", "College of Information Science", 3)
write_line("{0}", me.name) //=> Takuto Hayashi
write_line("{0}", me.college) //=> College of Information Science
write_line("{0}", me.grade) //=> 3

def UgradStudent#promote!(self):
  if(self.grade < 4):
    self.grade = self.grade + 1
  end
  self.grade
end

me.promote!
write_line("{0}", me.grade) //=> 4

trait Student(C, C#name, C#department):
  def C#introduce_oneself(self):
    write_line("My name is {0}. I'm a member of {1}.", self.name, self.department)
  end

  export C#introduce_oneself
end

class GradStudent = make_grad_student:
  name
  school
  mutable grade
end

let taro = make_grad_student("Taro Tsukuba", "Graduate School of Systems and Information Engineering", 1)

open Student(UgradStudent, UgradStudent#name, UgradStudent#college)
open Student(GradStudent, GradStudent#name, GradStudent#school)

me.introduce_oneself //=> My name is Takuto Hayashi. I'm a member of College of Information Science.
taro.introduce_oneself //=> My name is Taro Tsukuba. I'm a member of Graduate School of Systems and Information Engineering.


let lst1 = [1, 2, 3]
let lst2 = [4, 5, 6]
write_line("{0}", lst1) //=> [1, 2, 3]
write_line("{0}", lst2) //=> [4, 5, 6]
write_line("{0}", lst1 ++ lst2) //=> [1, 2, 3, 4, 5, 6]


trait Account(C, C#balance, C#(balance=)):
  def C#deposit!(self, x):
    self.balance = self.balance + x
  end

  def C#withdraw!(self, x):
    self.balance = self.balance - x
    if(self.balance < 0):
      self.balance = 0
    end
  end

  export C#deposit!, C#withdraw!
end

class BankAccount = make_bank_account:
  mutable balance
end

open Account(BankAccount, BankAccount#balance, BankAccount#(balance=))

def create_bank_account():
  make_bank_account(0)
end

let account = create_bank_account()

account.balance = 200
write_line("{0}(200)", account.balance)
account.deposit!(50)
write_line("{0}(250)", account.balance)
account.withdraw!(100)
write_line("{0}(150)", account.balance)
account.withdraw!(200)
write_line("{0}(0)", account.balance)

class StockAccount = make_stock_account:
  mutable num_shares
  mutable price_per_share
end

def StockAccount#balance(self):
  self.num_shares * self.price_per_share
end

def StockAccount#(balance=)(self, x):
  self.num_shares = x / self.price_per_share
end

open Account(StockAccount, StockAccount#balance, StockAccount#(balance=))

def create_stock_account():
  make_stock_account(10, 30)
end

let stock = create_stock_account()

write_line("{0}(10)", stock.num_shares)
write_line("{0}(30)", stock.price_per_share)
write_line("{0}(300)", stock.balance)
stock.balance = 150
write_line("{0}(5)", stock.num_shares)

stock.balance = 600
write_line("{0}(600)", stock.balance)
write_line("{0}(20)", stock.num_shares)
stock.deposit!(60)
write_line("{0}(660)", stock.balance)
write_line("{0}(22)", stock.num_shares)

class Point = make_point:
  x
  y
end

let p1 = make_point(1, 2)
let p2 = make_point(1, 2)
let p3 = make_point(2, 2)

module Temp:
  def Point#(==)(self, other):
    self.x == other.x && self.y == other.y
  end

  write_line("{0}", p1 == p2) //=> true
  write_line("{0}", p2 == p3) //=> false
end

//write_line("{0}", p1 == p2) //=> <error>


let x = (1, 2, 3, :p 4)

let (a, b, c, :p d, :q e=5) = x

write_line("{0}{1}{2}{3}{4}", a, b, c, d, e)


def my_if1(cond, then_thunk, :else else_thunk=^{}):
  if(cond):
    then_thunk()
  else:
    else_thunk()
  end
end

my_if1(true):
  write_line("ok!")
else:
  write_line("NG")
end

my_if1(true):
  write_line("ok!")
end

def my_if2(cond, :then then_thunk=^{}, :else else_thunk=^{}):
  if(cond):
    then_thunk()
  else:
    else_thunk()
  end
end

my_if2(false):
then:
  write_line("NG")
else:
  write_line("ok!")
end

my_if2(false):
else:
  write_line("ok!")
end

my_if2(false):
then:
  write_line("NG")
end

my_if2(false):
end

def my_while(test_thunk, :do body_thunk):
  while: test_thunk()
  do:
    body_thunk()
  end
end

def Ref::C#zero?(self):
  self.value == 0
end

def Ref::C#decr!(self):
  self.value = self.value - 1
  self.value
end

let counter = ref(5)
my_while: !counter.zero?
do:
  write_line("{0}", counter.decr!)
end


trait Reflect(bind):
  def reflect(m):
    shift^(k):
      bind(m, k)
    end
  end

  export reflect
end

begin:
  open Reflect(Option::bind)
  let result = reset:
    let a = reflect(List::find([1, 0, 3], ^(n){ n == 2 }))
    let b = reflect(List::find([2, 3, 1], ^(n){ n == 3 }))
    Some([a, b])
  end
  write_line("{0}", result)
  let result = reset:
    let a = reflect(List::find([1, 0, 3, 2], ^(n){ n == 2 }))
    let b = reflect(List::find([2, 3, 1], ^(n){ n == 3 }))
    Some([a, b])
  end
  write_line("{0}", result)
end

begin:
  open Reflect^(m, proc):
    List::flatten(List::map(m, proc))
  end
  let result = reset:
    let a = reflect([1, 2, 3])
    let b = reflect([4, 5, 6])
    let c = a * b
    if(c % 6 != 0):
      []
    else:
      [c]
    end
  end
  write_line("{0}", result)
end


module Coro:
  class C = make:
    mutable proc
    mutable prev
  end

  let current = ref(())

  def create(proc):
    make(proc, ())
  end

  def resume(coro):
    reset:
      coro.prev = current.value
      current.value = coro
      (coro.proc)()
    end
  end

  def yield(arg):
    shift^(k):
      current.value.proc = ^{ k(()) }
      current.value = current.value.prev
      arg
    end
  end

  export create, resume, yield
end

let coro = Coro::create:
  def loop(a, b):
    Coro::yield(a)
    loop(b, a + b)
  end
  loop(1, 1)
end

p(Coro::resume(coro))  //=> 1
p(Coro::resume(coro))  //=> 1
p(Coro::resume(coro))  //=> 2
p(Coro::resume(coro))  //=> 3
p(Coro::resume(coro))  //=> 5
p(Coro::resume(coro))  //=> 8


let h = Hash::create(13)
h["abc"] = "def"
h["ghi"] = "jkl"
h["mno"] = "pqr"
write_line("{0}", h)


module PEG:
  class Expr:
    def MkExpr(proc)
  end

  class Result:
    def Success(pos, value)
    def Failure()
  end

  def parse(MkExpr(expr), str):
    expr(str, 0, Hash::create(16))
  end

  trait New():
    let nonterms = Hash::create(16)
    
    def def_nt(name, MkExpr(expr)):
      nonterms[name] = expr
    end

    def char(c):
      MkExpr^(str, pos, caches):
        if(pos < String::length(str) && str[pos] == c):
          Success(pos + 1, c)
        else:
          Failure()
        end
      end
    end

    def string(s):
      let len = String::length(s)
      MkExpr^(str, pos, caches):
        if(pos + len <= String::length(str) && String::sub(str, pos, len) == s):
          Success(pos + len, s)
        else:
          Failure()
        end
      end
    end

    def char_set(cs):
      MkExpr^(str, pos, caches):
        if(pos < String::length(str) && String::contain?(cs, str[pos])):
          Success(pos + 1, str[pos])
        else:
          Failure()
        end
      end
    end

    def nt_ref(name):
      MkExpr^(str, pos, caches):
        match(Hash::get(caches, (name, pos))):
        case(Some(result)):
          result
        case(None()):
          let result = nonterms[name](str, pos, caches)
          caches[(name, pos)] = result
          result
        end
      end
    end

    let fail = MkExpr^(str, pos, caches):
      Failure()
    end

    let no_op = MkExpr^(str, pos, caches):
      Success(pos, ())
    end

    def seq(MkExpr(expr1), MkExpr(expr2)):
      MkExpr^(str, pos, caches):
        match(expr1(str, pos, caches)):
        case(Success(pos, value)):
          expr2(str, pos, caches)
        case(Failure()):
          Failure()
        end
      end
    end

    def alt(MkExpr(expr1), MkExpr(expr2)):
      MkExpr^(str, pos, caches):
        match(expr1(str, pos, caches)):
        case(Success(pos, value)):
          Success(pos, value)
        case(Failure()):
          expr2(str, pos, caches)
        end
      end
    end

    def zero_or_more(MkExpr(expr)):
      MkExpr^(str, pos, caches):
        def loop(rev_values, pos):
          match(expr(str, pos, caches)):
          case(Success(pos, value)):
            loop([value | rev_values], pos)
          case(Failure()):
            Success(pos, List::rev(rev_values))
          end
        end
        loop([], pos)
      end
    end

    def not(MkExpr(expr)):
      MkExpr^(str, pos, caches):
        match(expr(str, pos, caches)):
        case(Success(pos, value)):
          Failure()
        case(Failure()):
          Success(pos, ())
        end
      end
    end

    def return(value):
      MkExpr^(str, pos, caches):
        Success(pos, value)
      end
    end

    def bind(MkExpr(expr), proc):
      MkExpr^(str, pos, caches):
        match(expr(str, pos, caches)):
        case(Success(pos, value)):
          let MkExpr(expr) = proc(value)
          expr(str, pos, caches)
        case(Failure()):
          Failure()
        end
      end
    end

    def one_or_more(expr):
      bind(expr)^(value):
        bind(zero_or_more(expr))^(values):
          return([value | values])
        end
      end
    end

    def zero_or_one(expr):
      alt(expr, no_op)
    end

    def and(expr):
      not(not(expr))
    end

    let String::C#(<-) = def_nt
    let Expr#(&+) = seq
    let Expr#(|+) = alt

    export def_nt, char, string, char_set, nt_ref, fail, no_op, seq, alt, zero_or_more, not
    export return, bind, one_or_more, zero_or_one, and
    export String::C#(<-), Expr#(&+), Expr#(|+)
  end

  export Success, Failure, parse, New
end

let s = begin:
  open PEG::New()
  
  "S" <- and(nt_ref("A") &+ not(char('b')))
      &+ one_or_more(char('a'))
      &+ nt_ref("B")
      &+ not(char('c'))

  "A" <- char('a')
      &+ zero_or_one(nt_ref("A"))
      &+ char('b')

  "B" <- char('b')
      &+ zero_or_one(nt_ref("B"))
      &+char('c')

  nt_ref("S")
end

p(PEG::parse(s, ""))
p(PEG::parse(s, "abc"))
p(PEG::parse(s, "ab"))
p(PEG::parse(s, "aaabbbccc"))
p(PEG::parse(s, "aabbbccc"))

let e = begin:
  open PEG::New()
  open Reflect(bind)

  def digits_to_int(digits):
    List::fold_left(0, digits)^(n, digit):
      n * 10 + Char::digit_to_int(digit)
    end
  end

  "E" <- reset:
           let (v1, s1) = reflect(nt_ref("T"))
           let (v2, s2) = reflect(char('+') &+ nt_ref("E"))
           return((v1 + v2, String::format("({0} + {1})", s1, s2)))
         end
      |+ nt_ref("T")

  "T" <- reset:
           let (v1, s1) = reflect(nt_ref("P"))
           let (v2, s2) = reflect(char('*') &+ nt_ref("T"))
           return((v1 * v2, String::format("({0} * {1})", s1, s2)))
         end
      |+ nt_ref("P")

  "P" <- reset:
           let digits = reflect(one_or_more(char_set("0123456789")))
           return((digits_to_int(digits), String::concat_map(digits, "", Char::C#to_string)))
         end
      |+ reset:
           let (v, s)  = reflect(char('(') &+ nt_ref("E"))
           char(')') &+ return((v, s))
         end

  nt_ref("E")
end

p(PEG::parse(e, "123"))
p(PEG::parse(e, "1+2+3"))
p(PEG::parse(e, "(1+2)*3"))
